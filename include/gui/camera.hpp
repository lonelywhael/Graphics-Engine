#ifndef CAMERA_HPP
#define CAMERA_HPP

#include <iostream>

// matrix and vector arithmatic
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include "elements.hpp"

// defining the X, Y, and Z axes
const glm::vec3 X_AXIS = glm::vec3(1.0f, 0.0f, 0.0f), Y_AXIS = glm::vec3(0.0f, 1.0f, 0.0f), Z_AXIS(0.0f, 0.0f, 1.0f);
const float NEAR = 0.1f, FAR = 100.0f;

/* CAMERA CLASS:
 * The camera class stores information about where the player is and what direction they are looking in. It also stores viewer 
 * information that is used to generate view and projection matrices to be used in the rendering pipeline.
 * 
 * The camera class has several methods for handling movement and panning, and also for retrieving transformation matrices to be used
 * in the rendering pipeline.
 * 
 * A camera is designed to attach to a 3D shader, since the shader will require direct access to the transformation matrices generated by
 * the camera. It also needs to be accessible in order to recieve data from the window about user input.
 */

class Camera {
public:
    // Camera must be given starting location, a target to look at (the origin by default), and fov and aspect ratio
    Camera(const glm::vec3 pos, const float fov, const float aspectRatio) : Camera(pos, glm::vec3(0.0f), fov, aspectRatio) {}
    Camera(const glm::vec3 pos, const glm::vec3 target, const float fov, const float aspectRatio);

    // functions for adjusting the position of the camera
    void move(const glm::vec3 v, const float deltaTime);                    // move camera position a small amount in the v direction 
    void moveTo(const glm::vec3 pos) { this->pos = pos; setView(); }  // move camera to a new position
    glm::vec3 getPos() const { return pos; }
    void printPos() const;

    // functions for adjusting the direction of the camera via a target
    void lookAt() { view = glm::lookAt(pos, target, Y_AXIS); setDir(); }    // face camera towards a existing target location
    void lookAt(const glm::vec3 target) { this->target = target; lookAt(); }      // face camera towards a new target location
    glm::vec3 getDir() const { return dir; }

    // functions for adjusting the direction of the camera incrementally
    void setView() { view = glm::lookAt(pos, pos + dir, up); }              // update view matrix to current direction
    void turnTo(const glm::vec3 dir, const glm::vec3 up = Y_AXIS)                       // face camera in a new direction
        { this->dir = dir; this->up = up; setView(); } 
    void turnTo(const float yaw, const float pitch, const glm::vec3 up = Y_AXIS);

    // functions for adjusting fov and aspect ratio
    void setFOV(const float fov) { this->fov = fov; setProj(); }
    void setAspectRatio(const float aspectRatio) { this->aspectRatio = aspectRatio; setProj(); }

    // functions for retrieving tranformation matrices for the rendering pipeline
    glm::mat4 getView() const { return view; }  // view matrix transforms from world space to view space
    glm::mat4 getProj() const { return proj; }  // projection matrix transfroms from view space to clip space (adds depth, clips edges)
    void printView() const;
private:
    // position information about camera and target object
    glm::vec3 pos, target;
    // direction data
    glm::vec3 dir, up;
    // viewer data
    float fov, aspectRatio;

    // transformation matrices 
    glm::mat4 view, proj;

    // misc functions to keep variables updated and self-consistent
    void setDir();                                                                         // update direction based on new target
    void setProj() { proj = glm::perspective(glm::radians(fov), aspectRatio, NEAR, FAR); } // update proj matrix based on 
};


#endif